# -*- coding: utf-8 -*-
"""lab9.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1St6PCiUsPeW96jSCSwJk_STgqqYZc_wc
"""

import pandas as pd
import numpy as np
import tensorflow as tf
import keras
import pickle

#perceptrony i irysy

from sklearn.datasets import load_iris
iris = load_iris(as_frame=True)

pd.concat([iris.data, iris.target], axis=1).plot.scatter(
x='petal length (cm)',
y='petal width (cm)',
c='target',
colormap='viridis'
)

print(iris.feature_names)

from sklearn.model_selection import train_test_split

X_train, X_test, y_train, y_test = train_test_split(iris.data[["petal length (cm)", "petal width (cm)"]], iris.target, test_size=0.2)

from sklearn.linear_model import Perceptron

y_train_0 = (y_train == 0).astype(int)
y_train_1 = (y_train == 1).astype(int)
y_train_2 = (y_train == 2).astype(int)

y_test_0 = (y_test == 0).astype(int)
y_test_1 = (y_test == 1).astype(int)
y_test_2 = (y_test == 2).astype(int)

per_clf_0 = Perceptron()
per_clf_0.fit(X_train, y_train_0)

per_clf_1 = Perceptron()
per_clf_1.fit(X_train, y_train_1)

per_clf_2 = Perceptron()
per_clf_2.fit(X_train, y_train_2)

y_pred_train_0 = per_clf_0.predict(X_train)
y_pred_test_0 = per_clf_0.predict(X_test)

y_pred_train_1 = per_clf_1.predict(X_train)
y_pred_test_1 = per_clf_1.predict(X_test)

y_pred_train_2 = per_clf_2.predict(X_train)
y_pred_test_2 = per_clf_2.predict(X_test)

from sklearn.metrics import accuracy_score

acc_train_0 = accuracy_score(y_train_0, y_pred_train_0)
acc_test_0 = accuracy_score(y_test_0, y_pred_test_0)

acc_train_1 = accuracy_score(y_train_1, y_pred_train_1)
acc_test_1 = accuracy_score(y_test_1, y_pred_test_1)

acc_train_2 = accuracy_score(y_train_2, y_pred_train_2)
acc_test_2 = accuracy_score(y_test_2, y_pred_test_2)

per_acc = [(acc_train_0, acc_test_0), (acc_train_1, acc_test_1), (acc_train_2, acc_test_2)]

with open('per_acc.pkl', 'wb') as f:
    pickle.dump(per_acc, f, pickle.HIGHEST_PROTOCOL)

with open('per_acc.pkl', 'rb') as f:
    print(pickle.load(f))

w_0_0 = per_clf_0.intercept_[0]
w_0_1 = per_clf_0.coef_[0, 0]
w_0_2 = per_clf_0.coef_[0, 1]

w_1_0 = per_clf_1.intercept_[0]
w_1_1 = per_clf_1.coef_[0, 0]
w_1_2 = per_clf_1.coef_[0, 1]

w_2_0 = per_clf_2.intercept_[0]
w_2_1 = per_clf_2.coef_[0, 0]
w_2_2 = per_clf_2.coef_[0, 1]

per_wght = [(w_0_0, w_0_1, w_0_2),(w_1_0,w_1_1,w_1_2),(w_2_0,w_2_1,w_2_2)]

with open('per_wght.pkl', 'wb') as f:
    pickle.dump(per_wght, f, pickle.HIGHEST_PROTOCOL)

with open('per_wght.pkl', 'rb') as f:
    print(pickle.load(f))

#Perceptron i XOR

X = np.array([[0, 0],
[0, 1],
[1, 0],
[1, 1]])
y = np.array([0,
1,
1,
0])

per_clf_xor = Perceptron()
per_clf_xor.fit(X,y)
print(per_clf_xor.predict(X))

print(per_clf_xor.intercept_[0], per_clf_xor.coef_[0][0], per_clf_xor.coef_[0][1])

#XOR, drugie podej≈õcie

model = keras.models.Sequential()
model.add(keras.layers.Dense(2, activation="tanh", input_dim=2))
model.add(keras.layers.Dense(1, activation="sigmoid"))

model.compile(loss="binary_crossentropy",optimizer="sgd")

history = model.fit(X, y, epochs=100, verbose=False)
print(history.history['loss'])

model.predict(X)

model_exp = keras.models.Sequential()
model_exp.add(keras.layers.Dense(2, activation="tanh", input_dim=2))
model_exp.add(keras.layers.Dense(1, activation="sigmoid"))

z = False
while not z:
  model_exp.compile(loss="binary_crossentropy",optimizer=tf.keras.optimizers.Adam(learning_rate=0.15))
  history = model_exp.fit(X, y, epochs=100, verbose=False)
  if model_exp.predict(X)[0]<0.1 and model_exp.predict(X)[1]>0.9 and model_exp.predict(X)[2]>0.9 and model_exp.predict(X)[0]<0.1:
    z = True

model_exp.predict(X)

weights=model_exp.get_weights()
weights

with open('mlp_xor_weights.pkl', 'wb') as f:
    pickle.dump(weights, f, pickle.HIGHEST_PROTOCOL)

with open('mlp_xor_weights.pkl', 'rb') as f:
    print(pickle.load(f))

